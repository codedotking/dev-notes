## ZooKeeper 是什么

zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop 和 Hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。

## ZooKeeper 解决了什么痛点

使用分布式系统就无法避免对节点管理的问题(需要实时感知节点的状态、对节点进行统一管理等等)，而由于这些问题处理起来可能相对麻烦和提高了系统的复杂性，zookeeper作为一个能够**通用**解决这些问题的`中间件`就应运而生了。

## ZooKeeper 设计目的

1. 最终一致性：client 不论连接到哪个 Server，展示给它都是同一个视图，这是 zookeeper 最重要的性能。

2. 可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。

3. 实时性：zookeeper 保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用 sync() 接口。

4. 等待无关（wait-free）：慢的或者失效的 client 不得干预快速的 client 的请求，使得每个 client 都能有效的等待。

5. 原子性：更新只能成功或者失败，没有中间状态。

6. 顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。

## ZooKeeper 数据模型

Zookeeper 会维护一个具有层次关系的数据结构，它非常类似于一个标准的文件系统，如图所示：

<img title="" src="https://raw.githubusercontent.com/hewneyao/dev-notes/main/docs/public/images/zookeeper-model.png" alt="" data-align="center">

Zookeeper 这种数据结构有如下这些特点：

1）每个子目录项都被称作为 znode，znode 它所在的路径是节点的唯一标识。

2）znode  可以有子节点目录，并且每个 znode 可以存储数据，注意 EPHEMERAL（临时的）类型的目录节点不能有子节点目录。

3）znode 是有版本的（version），每个 znode 中存储的数据可以有多个版本，也就是一个访问路径中可以存储多份数据，version 号自动增加。

4）znode 可以是临时节点（EPHEMERAL），可以是持久节点（PERSISTENT）。如果创建的是临时节点，一旦创建这个 EPHEMERAL znode 的客户端与服务器失去联系，这个 znode 也将自动删除，Zookeeper 的客户端和服务器通信采用长连接方式，每个客户端和服务器通过心跳来保持连接，这个连接状态称为 session，如果 znode 是临时节点，这个 session 失效，znode 也就删除了。

5）znode 的目录名可以自动编号，如App1已经存在，再创建的话，将会自动命名为App2。

6）znode 可以被监控，包括这个目录节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知设置监控的客户端，这个是 Zookeepe r的核心特性，Zookeeper 的很多功能都是基于这个特性实现的。

7）ZXID 每次对 Zookeeper 的状态的改变都会产生一个 zxid（ZooKeeper Transaction Id），zxid 是全局有序的，如果 zxid1 小于 zxid2，则 zxid1 在 zxid2 之前发生。

## ZooKeeper Watcher 机制

zookeeper 中引入 Watcher 机制来实现分布式的通知功能，zookeeper 允许客户端向服务端注册一个 Watcher 监听，当服务点的的指定事件触发监听时，那么服务端就会向客户端发送事件通知，以便客户端完成逻辑操作（即客户端向服务端注册监听，并将 watcher 对象存在客户端的 WatcherManager 中，服务端触发事件后，向客户端发送通知，客户端收到通知后从 WacherManager 中取出对象来执行回调逻辑）

## ZooKeeper 工作原理

Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态。

为了保证事务的顺序一致性，zookeeper 采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了 zxid。实现中 zxid 是一个 64 位的数字，它高 32 位是 epoch 用来标识 leader 关系是否改变，每次一个 leader 被选出来，它都会有一个新的 epoch，标识当前属于那个 leader 的统治时期。低32位用于递增计数。

## ZooKeeper 典型应用场景

1. **数据发布/订阅**：动态获取数据，来实现配置信息的集中式管理和数据的动态更新， zookeeper 采用设计模式：推拉相结合（客户端向服务端注册自己需要关注的节点，一旦该节点数据发生变更，那么服务端就会向相应的客户端发送Watcher事件通知，客户端接到消息后，主动到服务端获取最新的数据）
   - 将应用中的配置信息放到 zookeeper 上集中处理，通常应用初始化时主动获取所需配置信息，并在相对应的节点注册 Watcher，以后配置信息每发生变更一次，就通知相应的订阅的客户端，客户端完成从节点获取最新的配置信息。
   - 分布式搜索服务中，索引元信息和服务器集群机器的节点状态存储在指定的 zookeeper 节点中，供客户端的订阅使用
   - 分布式日志收集系统，将应用日志以应用为任务单元收集日志，在 zookeeper 上以应用名为节点，把该应用的服务器IP做为子节点，当应用服务器出现宕机或服务器发生变化时，通知日志收集器，日志收集器获得最新的服务器信息，来实现收集日志的任务。
2. **负载均衡**：通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就须要在这些对等的服务器中选择一个来执行相关的业务逻辑，其中比较典型的是消息中间件中的生产者，消费者负载均衡。
   - 生产者负载均衡：metaq 发送消息的时候，生产者在发送消息的时候必须选择一台 broker 上的一个分区来发送消息，因此 metaq 在运行过程中，会把所有 broker 和对应的分区信息全部注册到 ZK 指定节点上，默认的策略是一个依次轮询的过程，生产者在通过 zookeeper获取分区列表之后，会按照 brokerId 和 partition 的顺序排列组织成一个有序的分区列表，发送的时候按照从头到尾循环往复的方式选择一个分区来发送消息。
3. **命名服务**：通过使用命名服务，客户端应用能够根据指定名字来获取资源的实体、服务地址和提供者的信息。
   - 分布式任务调度系统中，通过调用Zookeeper节点创建API中的顺序节点创建，返回全局唯一的命名，且可得到节点创建的顺序。
4. **分布式协调/通知**：将不同的分布式组件有机结合起来，协调分布式系统的全局运行流程。
   - 将需要互相协调的分布式系统组件注册在ZK同一节点上，并对该节点注册Wathcher，当其中一个组件更新节点信息时，其他节点将收到信息，并作出相应的处理。
5) **集群管理**：为了灵活的管理大规模的集群中机器的运行状态，统计宕机率等。
   - 在线云主机管理，首先将应用部署到这些机器上，在ZK上的机器列表节点下面创建临时子节点，机器列表节点发出“子节点变更的”的消息，
6) **Master选举**：避免重复劳动，提高集群的性能，让集群中的单机或部分集群去完成耗时操作。
   - 海量数据处理模型，用ZK强一致性选举出master，并让他处理耗时的海量数据，其余客户端在该节点注册Watcher，监控master的存活。
7. **分布式锁**：分布式锁的实现包括独占和控制时序
8. **分布式队列**：队列包括先进先出（FIFO）队列和队列成员聚齐。
   - 分布式环境中，一个大任务TaskA，需要在很多子任务完成（或条件就绪）情况下才能进行。这个时候，凡是其中一个子任务完成（就绪），那么就去 /taskList 下建立自己的临时时序节点（CreateMode.EPHEMERAL_SEQUENTIAL），当 /taskList 发现自己下面的子节点满足指定个数，就可以进行下一步按序进行处理了。